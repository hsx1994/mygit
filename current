
  CREATE OR REPLACE EDITIONABLE PACKAGE "CP01"."CP_RES_PKG_EASA" AS
/* Declare package procedure / functions */

/*******************************************************************************
 * Procedure Name: EXTRACT_EASA()
 * Description:    This procedure extracts data for EASA.
 ******************************************************************************/

PROCEDURE EXTRACT_EASA(I_JOB_REF_ID              IN   NUMBER,
                      O_RETURN_CODE              OUT  NUMBER);

/*******************************************************************************
 * Procedure Name: UPDATE_PRI_LEVEL()
 * Description:    This procedure updates the CP_OUTBUOND_EASA_PRI_TEMP table
				   for EASA processing.
 ******************************************************************************/

PROCEDURE UPDATE_PRI_LEVEL(I_JOB_REF_ID              IN   NUMBER,
						   O_RETURN_CODE             OUT  NUMBER);

/*******************************************************************************
 * Procedure Name: UPDATE_SEC_LEVEL()
 * Description:    This procedure updates the CP_OUTBUOND_EASA_SEC_TEMP table
				   for EASA processing.
 ******************************************************************************/

PROCEDURE UPDATE_SEC_LEVEL(I_JOB_REF_ID              IN   NUMBER,
						   O_RETURN_CODE             OUT  NUMBER);

/*******************************************************************************
 * Procedure Name: UPDATE_JC_LEVEL()
 * Description:    This procedure updates the CP_OUTBUOND_EASA_JC_TEMP table
				   for EASA processing.
 ******************************************************************************/

PROCEDURE UPDATE_JCCI_LEVEL(I_JOB_REF_ID              IN   NUMBER,
						   O_RETURN_CODE              OUT  NUMBER);


END CP_RES_PKG_EASA;
 
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "CP01"."CP_RES_PKG_EASA" AS
/* Declare package constants */
PKG_NAME                  CONSTANT  VARCHAR2(30) := 'CP_RES_PKG_EASA';
SUCCESS                   CONSTANT  NUMBER       := 0;
FAIL                      CONSTANT  NUMBER       := 100;
WARNING			  CONSTANT  NUMBER	 := 6;
STUD_WARNING		  CONSTANT  VARCHAR2(30)  := 'Student ';
EASA_OVERALL_AV_WARNING   CONSTANT  VARCHAR2(100) := ' has null EASA overall average. Student was not extracted for EASA.';
VR_MR_WARNING		  CONSTANT  VARCHAR2(100) := ' has 2 or more VR/MC for his/her results. Student was not extracted for EASA.';
RANKING_PTS_WARNING	  CONSTANT  VARCHAR2(100) := ' has null Ranking Points. Student was not extracted for EASA.';
--PASS_IND_WARNING		  CONSTANT  VARCHAR2(100) := ' has null Pass indictor. Student was not extracted for EASA.';
AGGR_WARNING		  CONSTANT  VARCHAR2(100) := ' The Level has no no overall total. Please proceed to  calculate Aggreate';
ACADAWARD_WARNING	  CONSTANT  VARCHAR2(100) := ' has null Academic Award Eligibility indicator. Student was not extracted for EASA.';
ERROR_XCODE		  CONSTANT  VARCHAR2(4)   := 'EASA';
ACTIVE		          CONSTANT  VARCHAR2(1)  := 'A';
YES			  CONSTANT  VARCHAR2(1)  := 'Y';
--<START ADD-001>--
OVERALL			  CONSTANT  VARCHAR2(2)  := '01'; --<ADD-001>--
SECOND_ICODE              CONSTANT  VARCHAR2(4)  := '0101';
--<END ADD-001>--
V_RET_CODE                NUMBER       := FAIL;


V_SCHOOL_CODE             VARCHAR2(10) := '';
V_ACADEMIC_YEAR           VARCHAR2(10) := '';
V_LEVEL_CODE              VARCHAR2(10) := '';
V_USER_ID                 VARCHAR2(14) := '';
V_SCH_MAINLEVEL           VARCHAR2(2)  := '';
V_IP_SCHOOL		  VARCHAR2(2)  := '';
V_CURRENT_YEAR		  VARCHAR2(4) := TO_CHAR(SYSDATE, 'YYYY');

/* Declare package procedure / functions */

/*******************************************************************************
 * Procedure Name: EXTRACT_EASA()
 * Description:    This procedure determines which procedure to call to process
				   EASA according to their main level.
 ******************************************************************************/
-- 09/03/2010   Josue Bongato	      To include components from 1st to 2nd to last tier

--              DATE              RESOURCE              DESCRIPTION
--ADD-001       08/09/2010        Josue Bongato		Add the following variable declarations:
--							OVERALL			  CONSTANT  VARCHAR2(2)  := '01';
--							SECOND_ICODE              CONSTANT  VARCHAR2(4)  := '0101';
--ADD-002      08/09/2010         Josue Bongato         Add the following condition to WHERE clause:
--							And rm.result_type_icode = OVERALL
--ADD-003      08/09/2010         Josue Bongato         Add the following condition to WHERE clause:
--							And rm.result_type_icode = OVERALL
--							And mk.result_type_icode = OVERALL
--ADD-004      08/09/2010         Josue Bongato         Add the following condition to WHERE clause of the second sub query :
--							old.academic_year = p_academic_year
--MOD-001       08/09/2010        Josue Bongato         Replace the the following IF STATEMENT:
--							IF (V_SCH_MAINLEVEL = PRI) OR (V_SCH_MAINLEVEL = FULL AND V_LEVEL_CODE > 10 AND V_LEVEL_CODE< 17)
--							With the following:
--							IF (V_SCH_MAINLEVEL = PRI) OR ((V_SCH_MAINLEVEL = `T5.  AND V_LEVEL_CODE > 10 AND V_LEVEL_CODE < 17) OR V_LEVEL_CODE=.91. )

--MOD-002       08/09/2010         Josue Bongato         Replace the the following IF STATEMENT:
--							ELSIF (V_SCH_MAINLEVEL = SEC) OR (V_SCH_MAINLEVEL = FULL AND V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36)
--							With the following:
--							ELSIF (V_SCH_MAINLEVEL = SEC) OR (V_SCH_MAINLEVEL = `T1.  AND V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36) OR (V_SCH_MAINLEVEL = `T2.  AND V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36)
--MOD-003       08/09/2010        Josue Bongato         Replace the the following IF STATEMENT:
--							ELSIF V_SCH_MAINLEVEL IN (JC, CI)
--							With the following:
--							ELSIF V_SCH_MAINLEVEL IN (JC, CI) OR (V_SCH_MAINLEVEL = `T1.  AND V_LEVEL_CODE > 35 AND V_LEVEL_CODE < 44) OR (V_SCH_MAINLEVEL = `T2.  AND V_LEVEL_CODE > 35 AND V_LEVEL_CODE < 44)
--MOD-004      08/09/2010         Josue Bongato          Replace CP_RESULT_STUD_AGGREGATES with CP_STUD_HIST_RES_AGGREGATES
--MOD-005      08/09/2010         Josue Bongato          Drop .SCHOOL_CODE = p_school_code.
--							AND	.LEVEL_XCODE = p_level_code.
--MOD-006      08/09/2010         Josue Bongato          Replace RESULT_TYPE_ICODE    = 'OV'
--							With RESULT_TYPE_ICODE    = OVERALL
--MOD-007      08/09/2010         Josue Bongato          Replace rm.s2_overall_conduct_code with
--							rm.overall_conduct_code
--MOD-008      08/09/2010         Josue Bongato          Replace	NVL(SUM(DECODE(mk.absent_icode_1, 'MC', 1, 'VR', 1, 0)),0)
--							with
--							NVL(SUM(DECODE(mk.absent_icode, 'MC', 1, 'VR', 1, 0)),0)
--MOD-009      08/09/2010         Josue Bongato          Replace CP_RESULT_STUD_AGGREGATES with CP_STUD_HIST_RES_AGGREGATES and
--							Replace CP_RESULT_STUD_OVRL_REMARKS with CP_STUD_HIST_RES_REMARKS
--MOD-010      08/09/2010         Josue Bongato          Replace CP_RESULT_STUD_MARKS with CP_STUD_HIST_RES_MARKS

--MOD-011      08/09/2010         Josue Bongato          Replace  CP_CUR_SCHOOL_SUBJECT with CP_CUR_SCHOOL_HIST_SUBJ
--MOD-012      08/09/2010         Josue Bongato          Replace ag.result_type_icode = OVERALL With ag.result_type_icode = OVERALL
--MOD-013      08/09/2010         Josue Bongato          Replace rm.s2_overall_conduct_code with rm.overall_conduct_code

--MOD-014      08/09/2010         Josue Bongato          Replace rm.s2_overall_conduct_code with rm.overall_conduct_code
--MOD-015      08/09/2010         Josue Bongato          Replace CP_RESULT_STUD_AGGREGATES with CP_STUD_HIST_RES_AGGREGATES
--MOD-016      08/09/2010         Josue Bongato          Replace ag.result_type_icode = 'OV'  With ag.result_type_icode = OVERALL
--MOD-017      08/09/2010         Josue Bongato          Replace TO_CHAR(NVL(SUM(DECODE(mk.grade_name_1, 'A', 1, 0)), 0))
--
--MOD-018      08/09/2010         Josue Bongato          Replace TO_CHAR(NVL(SUM(DECODE(mk.grade_name_1, 'B', 1, 0)), 0))
--							 with TO_CHAR(NVL(SUM(DECODE(mk.grade_name, 'B', 1, 0)), 0))
--MOD-019      08/09/2010         Josue Bongato          Replace rm.ov_overall_conduct_code with rm.overall_conduct_code
--MOD-020      08/09/2010         Josue Bongato          Replace CP_RESULT_STUD_AGGREGATES with CP_STUD_HIST_RES_AGGREGATES
--							 Replace CP_RESULT_STUD_OVRL_REMARKS with CP_STUD_HIST_RES_REMARKS
--							 Replace CP_RESULT_STUD_MARKS with CP_STUD_HIST_RES_MARKS
--MOD-021      08/09/2010         Josue Bongato          Replace  CP_CUR_SCHOOL_SUBJECT with CP_CUR_SCHOOL_HIST_SUBJ
--MOD-022      08/09/2010         Josue Bongato          Replace  rm.ov_overall_conduct_code with rm.overall_conduct_code





PROCEDURE EXTRACT_EASA(I_JOB_REF_ID              IN   NUMBER,
                      O_RETURN_CODE              OUT  NUMBER) IS

/* Declare constants */
PROC_NAME             CONSTANT  VARCHAR2(31) := '.EXTRACT_EASA';
PRI					  CONSTANT  VARCHAR(1)   := 'P';
SEC					  CONSTANT  VARCHAR(1)   := 'S';
JC					  CONSTANT  VARCHAR(1)   := 'J';
CI					  CONSTANT  VARCHAR(1)   := 'I';
FULL				  CONSTANT  VARCHAR(1)   := 'F';

/* Declare variables */

NO_MESSAGE            EXCEPTION;
APPL_ERROR            EXCEPTION;
NO_DATA               EXCEPTION;
RES_RETURN_CODE		  NUMBER;


--PRI_RETURN_CODE		  NUMBER;
--SEC_RETURN_CODE		  NUMBER;
--JCCI_RETURN_CODE	  NUMBER;

/* Declare Cursor */
CURSOR ASYNCJOB_PARAMETER_CURSOR1 IS
  SELECT CAAP1.PARAMETER_VALUE
  FROM   CP_ARCH_ASYNCJOB_PARAMETER CAAP1
  WHERE  CAAP1.JOB_REFID               = I_JOB_REF_ID
  AND    CAAP1.PARAMETER_SEQ_NO        = 1;

CURSOR ASYNCJOB_PARAMETER_CURSOR2 IS
  SELECT CAAP2.PARAMETER_VALUE
  FROM   CP_ARCH_ASYNCJOB_PARAMETER   CAAP2
  WHERE  CAAP2.JOB_REFID               = I_JOB_REF_ID
  AND    CAAP2.PARAMETER_SEQ_NO        = 2;

CURSOR ASYNCJOB_PARAMETER_CURSOR3 IS
  SELECT CAAP3.PARAMETER_VALUE
  FROM   CP_ARCH_ASYNCJOB_PARAMETER   CAAP3
  WHERE  CAAP3.JOB_REFID               = I_JOB_REF_ID
  AND    CAAP3.PARAMETER_SEQ_NO        = 3;

CURSOR ASYNCJOB_PARAMETER_CURSOR4 IS
  SELECT CAAP4.PARAMETER_VALUE
  FROM   CP_ARCH_ASYNCJOB_PARAMETER   CAAP4
  WHERE  CAAP4.JOB_REFID               = I_JOB_REF_ID
  AND    CAAP4.PARAMETER_SEQ_NO        = 4;


CURSOR  SCH_INFO_CURRENT_CURSOR (p_school_code VARCHAR2, p_level_code VARCHAR2) IS
SELECT  K.MAINLEVEL_GROUP
  FROM  CP_ARCH_SCHOOL s, CP_ARCH_SCHTYPE_LEVEL_LINK l, CP_ARCH_LEVEL k
 WHERE  l.mainlevel_code = s.mainlevel_code
   AND  l.schtype_level_status_icode=ACTIVE
   AND  l.level_xcode = p_level_code
   AND  S.SCHOOL_CODE = P_SCHOOL_CODE
   AND  K.LEVEL_STATUS_ICODE = 'A'
   AND  K.LEVEL_XCODE = L.LEVEL_XCODE
ORDER BY l.level_xcode DESC;

CURSOR IP_CHECK_CURSOR (p_school_code VARCHAR2) IS
SELECT 'Y' AS IP_SCHOOL
FROM   CP_CODE_SCHOOL
WHERE  CATEGORY_NAME = 'IPSCHOOL'
AND    CODE_VALUE    = p_school_code;

BEGIN
--dbms_output.put_line(' BEGIN ');
/* Get the input values from the CP_ARCH_ASYNCJOB_PARAMETER table */
OPEN ASYNCJOB_PARAMETER_CURSOR1;
FETCH ASYNCJOB_PARAMETER_CURSOR1 INTO V_SCHOOL_CODE;
IF NOT ASYNCJOB_PARAMETER_CURSOR1%ISOPEN THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR1;
  V_RET_CODE := SQLCODE;
  RAISE APPL_ERROR;
ELSIF ASYNCJOB_PARAMETER_CURSOR1%NOTFOUND THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR1;
  V_RET_CODE := FAIL;
  RAISE APPL_ERROR;
END IF;
CLOSE ASYNCJOB_PARAMETER_CURSOR1;

OPEN ASYNCJOB_PARAMETER_CURSOR2;
FETCH ASYNCJOB_PARAMETER_CURSOR2 INTO V_ACADEMIC_YEAR;
IF NOT ASYNCJOB_PARAMETER_CURSOR2%ISOPEN THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR2;
  V_RET_CODE := SQLCODE;
  RAISE APPL_ERROR;
ELSIF ASYNCJOB_PARAMETER_CURSOR2%NOTFOUND THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR2;
  V_RET_CODE := FAIL;
  RAISE APPL_ERROR;
END IF;
CLOSE ASYNCJOB_PARAMETER_CURSOR2;

OPEN ASYNCJOB_PARAMETER_CURSOR3;
FETCH ASYNCJOB_PARAMETER_CURSOR3 INTO V_LEVEL_CODE;
IF NOT ASYNCJOB_PARAMETER_CURSOR3%ISOPEN THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR3;
  V_RET_CODE := SQLCODE;
  RAISE APPL_ERROR;
ELSIF ASYNCJOB_PARAMETER_CURSOR3%NOTFOUND THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR3;
  V_RET_CODE := FAIL;
  RAISE APPL_ERROR;
END IF;
CLOSE ASYNCJOB_PARAMETER_CURSOR3;

OPEN ASYNCJOB_PARAMETER_CURSOR4;
FETCH ASYNCJOB_PARAMETER_CURSOR4 INTO V_USER_ID;
IF NOT ASYNCJOB_PARAMETER_CURSOR4%ISOPEN THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR4;
  V_RET_CODE := SQLCODE;
  RAISE APPL_ERROR;
ELSIF ASYNCJOB_PARAMETER_CURSOR4%NOTFOUND THEN
  CLOSE ASYNCJOB_PARAMETER_CURSOR4;
  V_RET_CODE := FAIL;
  RAISE APPL_ERROR;
END IF;
CLOSE ASYNCJOB_PARAMETER_CURSOR4;

/* Make sure academic is equal to current year. */
IF V_CURRENT_YEAR = V_ACADEMIC_YEAR
THEN

	/* GET THE SCH_MAINLEVEL */
	OPEN  SCH_INFO_CURRENT_CURSOR (V_SCHOOL_CODE, V_LEVEL_CODE);
	FETCH SCH_INFO_CURRENT_CURSOR INTO V_SCH_MAINLEVEL;
	IF NOT SCH_INFO_CURRENT_CURSOR%ISOPEN THEN
		CLOSE SCH_INFO_CURRENT_CURSOR;
		V_RET_CODE := SQLCODE;
		 RAISE APPL_ERROR;
	ELSIF SCH_INFO_CURRENT_CURSOR%NOTFOUND THEN
		CLOSE SCH_INFO_CURRENT_CURSOR;
		V_RET_CODE := FAIL;
		RAISE APPL_ERROR;
	END IF;
	CLOSE SCH_INFO_CURRENT_CURSOR;

	/* PRIMARY SCHOOL LEVEL */
	--<START MOD - 001>--
	IF (V_SCH_MAINLEVEL = PRI) --OR ((V_SCH_MAINLEVEL = 'T5'  AND V_LEVEL_CODE > 10 AND V_LEVEL_CODE < 17) OR V_LEVEL_CODE='91' )
	--<START MOD - 001>--
	THEN
	----dbms_output.put_line('PRIMARY' ||V_SCHOOL_CODE||'-'|| V_SCH_MAINLEVEL ||'-'||I_JOB_REF_ID );
		/* RETRIEVE STUDENT FROM PRIMARY LEVEL */
		UPDATE_PRI_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);

	/* SECONDARY SCHOOL LEVEL */
	--<START MOD-002>--
	ELSIF (V_SCH_MAINLEVEL = SEC) --OR (V_SCH_MAINLEVEL = 'T1'  AND V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36) OR (V_SCH_MAINLEVEL = 'T2'  AND V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36)
	--<END MOD-002>--
	THEN

		/* RETRIEVE STUDENT FROM SECONDARY LEVEL */
		UPDATE_SEC_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);

	/* JCCI LEVEL */
	--<START MOD-003>--
		ELSIF V_SCH_MAINLEVEL IN (JC, CI) --OR (V_SCH_MAINLEVEL = 'T1'  AND V_LEVEL_CODE > 35 AND V_LEVEL_CODE < 44) OR (V_SCH_MAINLEVEL = 'T2'  AND V_LEVEL_CODE > 35 AND V_LEVEL_CODE < 44)
	--<END MOD-003>--
		THEN
      /* RETRIEVE STUDENT FROM JC LEVEL */
			UPDATE_JCCI_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);
		/*	CATER FOR IP SCHOOL */
--		OPEN  IP_CHECK_CURSOR (V_SCHOOL_CODE);
--		IF NOT IP_CHECK_CURSOR%ISOPEN THEN
--			CLOSE IP_CHECK_CURSOR;
--			V_IP_SCHOOL := '';
--		ELSIF IP_CHECK_CURSOR%NOTFOUND THEN
--			CLOSE IP_CHECK_CURSOR;
--			V_IP_SCHOOL := '';
--		ELSE
--			FETCH IP_CHECK_CURSOR INTO V_IP_SCHOOL;
--		END IF;
--		CLOSE IP_CHECK_CURSOR;

--		IF V_IP_SCHOOL = 'Y' AND V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36
--		THEN
			/* RETRIEVE STUDENT FROM SECONDARY LEVEL */
--			UPDATE_SEC_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);
--		ELSE
			/* RETRIEVE STUDENT FROM JC LEVEL */
--			UPDATE_JCCI_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);
--		END IF;
		/* Catch New IP SchoolType */
--	ELSE
--		IF V_LEVEL_CODE > 30 AND V_LEVEL_CODE < 36 THEN
			/* RETRIEVE STUDENT FROM SECONDARY LEVEL */
--			UPDATE_SEC_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);
--		ELSE
			/* RETRIEVE STUDENT FROM JC LEVEL */
--			UPDATE_JCCI_LEVEL(I_JOB_REF_ID,RES_RETURN_CODE);
--		END IF;

	END IF;

END IF;

IF RES_RETURN_CODE != SUCCESS
THEN

	/* IF THERE IS WARNING MESSAGE GENERATED */
	IF RES_RETURN_CODE = WARNING THEN
	--dbms_output.put_line('2 WARNING is 6 - ' || RES_RETURN_CODE);
		/* UPDATE THE ASYNJOB TABLE FOR THE STATUS */
		BEGIN
		UPDATE CP_ARCH_ASYNCJOB SET JOBSTATUS_XCODE = 6,
									COMPLETION_DATE = SYSDATE
		WHERE  JOB_SYS_CODE = I_JOB_REF_ID;

		EXCEPTION
				WHEN NO_DATA_FOUND THEN
					 --dbms_output.PUT_LINE('NOT FOUND JOB_REF_ID');
					 NULL;
				WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
			--	IF SQL%NOTFOUND THEN
			--		V_RET_CODE := FAIL;
			--		RAISE APPL_ERROR;
			--	END IF;
			BEGIN
			/* Commit changes */
			COMMIT;
			EXCEPTION
					 WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
		/* Return success code */
		O_RETURN_CODE := RES_RETURN_CODE;
	ELSE
		/* UPDATE THE ASYNJOB TABLE FOR THE STATUS */
		--dbms_output.put_line('3 WARNING is 6 in ELSE - ');
	    BEGIN
		UPDATE CP_ARCH_ASYNCJOB SET JOBSTATUS_XCODE = 2,
									COMPLETION_DATE = SYSDATE
		WHERE  JOB_SYS_CODE = I_JOB_REF_ID;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					 --dbms_output.PUT_LINE('NOT FOUND JOB_REF_ID');
					 NULL;
				WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
			--	IF SQL%NOTFOUND THEN
			--		V_RET_CODE := FAIL;
			--		RAISE APPL_ERROR;
			--	END IF;
			BEGIN
			/* Commit changes */
			COMMIT;
			EXCEPTION
					 WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
		/* Return success code */
		O_RETURN_CODE := RES_RETURN_CODE;
	END IF;

ELSE
	/* UPDATE THE ASYNJOB TABLE FOR THE STATUS */
		--dbms_output.put_line('4 WARNING is 6 in ELSE - ');
	BEGIN
	UPDATE CP_ARCH_ASYNCJOB SET JOBSTATUS_XCODE = 3,
								COMPLETION_DATE = SYSDATE
	WHERE  JOB_SYS_CODE = I_JOB_REF_ID;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					 --dbms_output.PUT_LINE('NOT FOUND JOB_REF_ID');
					 NULL;
				WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
			--	IF SQL%NOTFOUND THEN
			--		V_RET_CODE := FAIL;
			--		RAISE APPL_ERROR;
			--	END IF;
			BEGIN
			/* Commit changes */
			COMMIT;
			EXCEPTION
					 WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
	/* Return success code */
	O_RETURN_CODE := SUCCESS;
END IF;

EXCEPTION
  WHEN NO_MESSAGE THEN
    /* No Summary */
    O_RETURN_CODE       := SUCCESS;

  WHEN NO_DATA THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN APPL_ERROR THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN OTHERS THEN
    /*  SQL error */
    O_RETURN_CODE       := SQLCODE;

END EXTRACT_EASA;

/*******************************************************************************
 * Procedure Name: UPDATE_PRI_LEVEL()
 * Description:    Retrieve student that are eligible for EASA.
 ******************************************************************************/

PROCEDURE UPDATE_PRI_LEVEL(I_JOB_REF_ID              IN   NUMBER,
						   O_RETURN_CODE             OUT  NUMBER) IS

/* Declare constants */
PROC_NAME             CONSTANT  VARCHAR2(31) := '.UPDATE_PRI_LEVEL';
VR_MC_VALUE			  CONSTANT  NUMBER		 := 2;


/* Declare variables */
NO_MESSAGE            EXCEPTION;
APPL_ERROR            EXCEPTION;
NO_DATA               EXCEPTION;
V_PRI_CHECK			  NUMBER;
V_INACTIVE_PRI		  NUMBER;
V_CHK_AGGR			  NUMBER;
WARNING_CHECK		  NUMBER				 := 0;
CHECK_ERR			  NUMBER				 := 0;
WARNING_MSG			  VARCHAR2(200);
V_PREV_UINFIN		  VARCHAR2(14);

/* Declare Cursor */
CURSOR check_exist_pri_data_cursor
	(p_school_code VARCHAR2, p_level_code VARCHAR2, p_uin_fin_no VARCHAR2) IS
SELECT	COUNT(1)
  FROM	CP_OUTBOUND_EASA_PRI_TEMP
 WHERE	school_code = p_school_code
   AND	level_xcode = p_level_code
   AND	uin_fin_no = p_uin_fin_no;

CURSOR	RETRIEVE_PRI_INACTIVE_CURSOR
		(p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT	sp.uin_fin_no
  FROM	CP_STUD_PROFILE SP
 WHERE	STUDENT_STATUS_ICODE = 'I'
   AND	ACADEMIC_YEAR = p_academic_year
   AND	LEVEL_XCODE = p_level_code
   AND	SCHOOL_CODE = p_school_code;

CURSOR	RETRIEVE_AGG_CURSOR
		(p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT	COUNT(1)
  FROM	CP_STUD_HIST_RES_AGGREGATES CRA, --<MOD-004>-
        CP_STUD_HIST_PROMOTION CSP
 WHERE	--<START MOD-005>--
   --SCHOOL_CODE = p_school_code --<MOD-005>-
   --AND LEVEL_XCODE = p_level_code AND
        --<END MOD-005>--
       CSP.SCHOOL_CODE = p_school_code
   AND CSP.LEVEL_XCODE = p_level_code
   AND CSP.ACADEMIC_YEAR = p_academic_year
   AND CSP.STUDENT_STATUS_ICODE = 'A'
   AND CRA.STUDENT_ID = CSP.STUDENT_ID
   AND CRA.ACADEMIC_YEAR = CSP.ACADEMIC_YEAR
   AND CRA.RESULT_TYPE_ICODE = OVERALL ; --<MOD-006>--


CURSOR  RETRIEVE_PRI_CURRENT_CURSOR
        (p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT  sp.academic_year										academic_year,
	sp.student_id												student_id,
	sp.uin_fin_no												uin_fin_no,
	sp.class_xcode,
	ag.eass_overall_percentages_no								eass_overall_percentages_no,
	rm.overall_conduct_code									conduct_code, --<MOD-007>--
	--<START MOD-008>--
	NVL(SUM(DECODE(mk.absent_icode, 'MC', 1, 'VR', 1, 0)), 0)	count_VR_MC
	--<END MOD-008>--
  FROM  --<START MOD-009>--
	CP_STUD_HIST_RES_AGGREGATES ag,
        CP_STUD_HIST_RES_REMARKS rm,
	--<END MOD-009>--
        CP_STUD_PROFILE sp,
	--<START MOD-010>--
        CP_STUD_HIST_RES_MARKS mk
	--<END MOD-010>--
 WHERE  rm.student_id(+) = sp.student_id
   AND  RM.ACADEMIC_YEAR(+) = P_ACADEMIC_YEAR
   AND  AG.STUDENT_ID(+) = SP.STUDENT_ID
   AND  AG.RESULT_TYPE_ICODE(+) = OVERALL
   AND  ag.academic_year(+) = p_academic_year
   AND  sp.student_status_icode = ACTIVE
   --AND  (sp.leave_of_absence_ind = 'N' OR sp.leave_of_absence_ind IS NULL) -- Not necessery as active students are picked up
   AND  sp.level_xcode = p_level_code
   AND  sp.school_code = p_school_code
   AND  sp.academic_year = p_academic_year
   AND  MK.STUDENT_ID(+) = SP.STUDENT_ID
   AND  MK.ACADEMIC_YEAR(+) = SP.ACADEMIC_YEAR
   --AND  mk.subject_level_xcode(+) = sp.level_xcode
   --AND  mk.subject_stream_xcode = sp.stream_xcode
   AND  mk.subject_active_ind = YES
   --<START ADD-002>--
   AND  RM.RESULT_TYPE_ICODE(+) = OVERALL--SECOND_ICODE
   AND  mk.result_type_icode(+) = OVERALL
   --<END ADD-002>--
   AND  (mk.subject_code, mk.subject_level_xcode, mk.subject_stream_xcode) IN
	(SELECT od.subject_code, od.level_xcode, od.stream_xcode
	FROM  --<START MOD-011>--
	      CP_CUR_SCHOOL_HIST_SUBJ od
	      --<END MOD-011>--
	WHERE od.subject_school_code = p_school_code
        AND   od.level_xcode         = mk.subject_level_xcode 		   -- added newly to cater for outof stream subjects
        AND   od.stream_xcode        = mk.SUBJECT_STREAM_XCODE 		   -- added newly to cater for outof stream subjects
        AND   od.examinable_ind      = YES
        AND   od.academic_year       = p_academic_year)
 GROUP BY sp.academic_year, sp.student_id, sp.uin_fin_no, sp.class_xcode, ag.eass_overall_percentages_no, rm.overall_conduct_code
 ORDER BY sp.uin_fin_no;

CURSOR RETRIEVE_PREV_NRIC_CURSOR
		(p_student_id VARCHAR2) IS
SELECT CAPN.PREV_UIN_FIN_NO
  FROM CP_ARCH_PREV_NRIC CAPN
 WHERE CAPN.PERSON_ID = p_student_id;

BEGIN
	--dbms_output.put_line('PRI BEGIN ');
	/* REMOVE INACTIVE STUDENTS FROM THE OUTBOUND TABLES */
	FOR INACTIVE_RECORD IN RETRIEVE_PRI_INACTIVE_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR)
	LOOP
		--dbms_output.put_line('IN FOR - '|| V_SCHOOL_CODE || '-'|| V_LEVEL_CODE || '-'|| V_ACADEMIC_YEAR);
		/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
		OPEN check_exist_pri_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, INACTIVE_RECORD.uin_fin_no);
		FETCH check_exist_pri_data_cursor INTO V_INACTIVE_PRI;
		IF NOT check_exist_pri_data_cursor%ISOPEN THEN
		--dbms_output.put_line('fetch');
			CLOSE check_exist_pri_data_cursor;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF check_exist_pri_data_cursor%NOTFOUND THEN
		--dbms_output.put_line('fetch else if');
			CLOSE check_exist_pri_data_cursor;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE check_exist_pri_data_cursor;


		/* DELETE STUDENT FROM OUTBOUND TABLE IF STUDENT IS INACTIVE */
		IF V_INACTIVE_PRI > 0
			THEN
			--dbms_output.put_line('delete inactive' || INACTIVE_RECORD.uin_fin_no);
			BEGIN
				DELETE FROM CP_OUTBOUND_EASA_PRI_TEMP
				 WHERE SCHOOL_CODE = V_SCHOOL_CODE
				   AND LEVEL_XCODE = V_LEVEL_CODE
				   AND UIN_FIN_NO  = INACTIVE_RECORD.uin_fin_no
				   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					 --dbms_output.PUT_LINE('NOT FOUND JOB_REF_ID');
					 NULL;
				WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;

			BEGIN
			/* Commit changes */
			COMMIT;
			EXCEPTION
					 WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;

			END IF;

	END LOOP;

	WARNING_CHECK := 0;
	CHECK_ERR := 0;
	FOR tmp_record IN RETRIEVE_PRI_CURRENT_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR)
	LOOP

		--dbms_output.put_line('2nd FOR' );
		/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
		OPEN check_exist_pri_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, tmp_record.uin_fin_no);
		FETCH check_exist_pri_data_cursor INTO V_PRI_CHECK;
		IF NOT check_exist_pri_data_cursor%ISOPEN THEN
			CLOSE check_exist_pri_data_cursor;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF check_exist_pri_data_cursor%NOTFOUND THEN
			CLOSE check_exist_pri_data_cursor;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE check_exist_pri_data_cursor;

		/* IF STUDENT CANNOT BE FOUND IN TEMP TABLE, CHECK IF USER CHANGED UINFIN. */
		IF V_PRI_CHECK = 0 OR V_PRI_CHECK IS NULL
		THEN

			OPEN RETRIEVE_PREV_NRIC_CURSOR(tmp_record.student_id);
			FETCH RETRIEVE_PREV_NRIC_CURSOR INTO V_PREV_UINFIN;
			IF NOT RETRIEVE_PREV_NRIC_CURSOR%ISOPEN THEN
			--dbms_output.put_line('wil fetch');
				CLOSE RETRIEVE_PREV_NRIC_CURSOR;
				V_RET_CODE := SQLCODE;
				RAISE APPL_ERROR;
			ELSIF RETRIEVE_PREV_NRIC_CURSOR%NOTFOUND THEN
			--dbms_output.put_line('wil fetch else if');
				--CLOSE RETRIEVE_PREV_NRIC_CURSOR;
				--V_RET_CODE := FAIL;
				--RAISE APPL_ERROR;
				V_PREV_UINFIN := NULL;
			END IF;
			CLOSE RETRIEVE_PREV_NRIC_CURSOR;

			/* IF USER CHANGED NRIC, CHECK IF USER EXIST IN TEMP TABLE WITH PREV NRIC. */
			IF V_PREV_UINFIN IS NOT NULL
			THEN
				--dbms_output.put_line('2nd FOR' );
				/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
				OPEN check_exist_pri_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, V_PREV_UINFIN);
				FETCH check_exist_pri_data_cursor INTO V_PRI_CHECK;
				IF NOT check_exist_pri_data_cursor%ISOPEN THEN
					CLOSE check_exist_pri_data_cursor;
					V_RET_CODE := SQLCODE;
					RAISE APPL_ERROR;
				ELSIF check_exist_pri_data_cursor%NOTFOUND THEN
					CLOSE check_exist_pri_data_cursor;
					V_RET_CODE := FAIL;
					RAISE APPL_ERROR;
				END IF;
				CLOSE check_exist_pri_data_cursor;

				IF V_PRI_CHECK > 0 THEN
					BEGIN
						DELETE FROM CP_OUTBOUND_EASA_PRI_TEMP
						 WHERE SCHOOL_CODE = V_SCHOOL_CODE
						   AND LEVEL_XCODE = V_LEVEL_CODE
						   AND UIN_FIN_NO  = V_PREV_UINFIN
						   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

						EXCEPTION
						WHEN OTHERS THEN
							--dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
							dbms_output.put_line(SQLCODE);
							dbms_output.put_line(SQLERRM);
					END;
					--IF SQL%NOTFOUND THEN
					--	V_RET_CODE := FAIL;
					--	RAISE APPL_ERROR;
					--END IF;

					/* Commit changes */
					BEGIN
						COMMIT;
						EXCEPTION
						WHEN OTHERS THEN
							--dbms_output.put_line('COMMIT_ERROR');
							dbms_output.put_line(SQLCODE);
							dbms_output.put_line(SQLERRM);
					END;
					/* RESET V_PRI_CHECK, SO THAT RECORD WILL BE INSERTED. */
					V_PRI_CHECK := 0;
				END IF;
			END IF;
		END IF;

		/* Check if the aggreate is calculated for the level(at least) or not if not warn user.
		Not necessery to verify level stream combination*/
		OPEN RETRIEVE_AGG_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR);
		FETCH RETRIEVE_AGG_CURSOR INTO V_CHK_AGGR;
		IF NOT RETRIEVE_AGG_CURSOR%ISOPEN THEN
		--dbms_output.put_line('fetch');
			CLOSE RETRIEVE_AGG_CURSOR;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF RETRIEVE_AGG_CURSOR%NOTFOUND THEN
		--dbms_output.put_line('fetch else if');
			CLOSE RETRIEVE_AGG_CURSOR;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE RETRIEVE_AGG_CURSOR;

		IF (V_CHK_AGGR IS NULL OR V_CHK_AGGR = 0) THEN
				--dbms_output.put_line('1st WARN %' );
		    BEGIN
			WARNING_MSG := AGGR_WARNING || V_SCHOOL_CODE || ',' || V_LEVEL_CODE || V_ACADEMIC_YEAR;
			CHECK_ERR := 1;

			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;
		END IF;

		/* IF EASA_OVERALL_PERCENTAGES_NO IS NULL, GENERATE WARNING MESSAGE */
		IF tmp_record.eass_overall_percentages_no IS NULL THEN
				--dbms_output.put_line('1st WARN %' );
		    BEGIN
			WARNING_MSG := STUD_WARNING || tmp_record.uin_fin_no || ',' || tmp_record.class_xcode || EASA_OVERALL_AV_WARNING;
			CHECK_ERR := 1;

			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;

		END IF;
		/* IF VR AND MC COUNT >= 2, GENERATE WARNING MESSAGE */
		IF tmp_record.count_VR_MC >= VR_MC_VALUE AND CHECK_ERR != 1 THEN
				--dbms_output.put_line('2st WARN' || VR_MC_VALUE);
			BEGIN
			WARNING_MSG := STUD_WARNING || tmp_record.uin_fin_no || ',' || tmp_record.class_xcode || VR_MR_WARNING;
			CHECK_ERR := 1;
			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;

		END IF;
		/* WARNING MESSAGE TO BE GENERATED */
		IF CHECK_ERR = 1 THEN
			--dbms_output.put_line('INSERT TO CP_ARCH_JOB_ERRORS-');
		   BEGIN
			INSERT INTO CP_ARCH_JOB_ERRORS(
								JOB_REFID,
								JOB_ERROR_XCODE,
								REMARKS_DESC,
								RECORD_VERSION_NO,
								CREATED_DATE,
								CREATED_BY_ID,
								LAST_UPDATED_DATE,
								UPDATED_BY_ID
								)
			VALUES
								(I_JOB_REF_ID,
								ERROR_XCODE,
								WARNING_MSG,
								1,
								SYSDATE,
								V_USER_ID,
								SYSDATE,
								V_USER_ID
								);
								--dbms_output.put_line('AFTER INSERT');
			EXCEPTION
			   WHEN DUP_VAL_ON_INDEX THEN
					--dbms_output.put_line('DUPLICAE-M');
			        NULL;
			   WHEN OTHERS THEN
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		    END;

			/* Commit changes */
			--dbms_output.PUT_LINE('CHECKMINUS1'||O_return_code);
			BEGIN
			COMMIT;
			EXCEPTION
			   WHEN OTHERS THEN
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		    END;
			/* NOTIFIED THE CALLING PROCEDURE THAT THERE IS WARNING MESSAGE GENERATED */
			--dbms_output.PUT_LINE('CHECK0'||O_return_code);
			WARNING_CHECK := 1;
			CHECK_ERR := 0;
			--dbms_output.PUT_LINE('CHECK1'||O_return_code);
			IF V_PRI_CHECK > 0
			THEN
				--dbms_output.put_line('V_PRI_CHECK > 0' || tmp_record.uin_fin_no);
				BEGIN
				DELETE FROM CP_OUTBOUND_EASA_PRI_TEMP
				 WHERE SCHOOL_CODE = V_SCHOOL_CODE
				   AND LEVEL_XCODE = V_LEVEL_CODE
				   AND UIN_FIN_NO  = tmp_record.uin_fin_no
				   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;
                EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
				--	V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			END IF;
			--dbms_output.put_line('check2'||O_RETURN_CODE);
		ELSE

		    --dbms_output.put_line('check3'||O_RETURN_CODE);
			/* IF EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE, DO A UPDATE */
			IF V_PRI_CHECK > 0
			THEN
			--dbms_output.put_line('UPDATE CP_OUTBOUND_EASA_PRI_TEMP' || tmp_record.uin_fin_no);
				BEGIN
				UPDATE CP_OUTBOUND_EASA_PRI_TEMP SET EASA_OVERALL_PERCENTAGES_NO = tmp_record.eass_overall_percentages_no,
						S2_OVERALL_CONDUCT_CODE = tmp_record.conduct_code,
						LAST_UPDATED_DATE = SYSDATE,
						UPDATED_BY_ID = V_USER_ID
				WHERE	SCHOOL_CODE = V_SCHOOL_CODE
					AND LEVEL_XCODE = V_LEVEL_CODE
					AND UIN_FIN_NO = tmp_record.uin_fin_no
					AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;
                EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('UPDATE_ERROR ON FIN'||tmp_record.uin_fin_no);
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
		--	IF SQL%NOTFOUND THEN
		--			V_RET_CODE := FAIL;
		--			RAISE APPL_ERROR;
		--		END IF;

				/* Commit changes */
		BEGIN
			   COMMIT;
               EXCEPTION
			   WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT CP_OUTBOUND_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			/* IF NOT EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE, DO AN INSERT */
			ELSE
			--dbms_output.put_line('INSERT' || tmp_record.uin_fin_no);
			BEGIN
				INSERT INTO CP_OUTBOUND_EASA_PRI_TEMP(
								SCHOOL_CODE,
								LEVEL_XCODE,
								ACADEMIC_YEAR,
								UIN_FIN_NO,
								EASA_OVERALL_PERCENTAGES_NO,
								S2_OVERALL_CONDUCT_CODE,
								CREATED_DATE,
								CREATED_BY_ID,
								LAST_UPDATED_DATE,
								UPDATED_BY_ID)
				VALUES
								(V_SCHOOL_CODE,
								V_LEVEL_CODE,
								V_ACADEMIC_YEAR,
								tmp_record.uin_fin_no,
								tmp_record.eass_overall_percentages_no,
								tmp_record.conduct_code,
								SYSDATE,
								V_USER_ID,
								SYSDATE,
								V_USER_ID);

			               EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('INSERT CP_OUTBOUND_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;

				/* Commit changes */
				BEGIN
				COMMIT;
			               EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT CP_OUTBOUND_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			END IF;
			--dbms_output.put_line('check4'||O_RETURN_CODE);
		END IF;
--dbms_output.put_line('END LOOP');
	END LOOP;

IF WARNING_CHECK = 1 THEN
	O_RETURN_CODE := WARNING;
ELSE
	/* Return success code */
	O_RETURN_CODE := SUCCESS;
END IF;

EXCEPTION
  WHEN NO_MESSAGE THEN
    /* No Summary */
    O_RETURN_CODE       := SUCCESS;

  WHEN NO_DATA THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN APPL_ERROR THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN OTHERS THEN
    /*  SQL error */
    O_RETURN_CODE       := SQLCODE;

END UPDATE_PRI_LEVEL;

/*******************************************************************************
 * Procedure Name: UPDATE_SEC_LEVEL()
 * Description:    Retrieve student that are eligible for EASA.
 ******************************************************************************/

PROCEDURE UPDATE_SEC_LEVEL(I_JOB_REF_ID              IN   NUMBER,
						   O_RETURN_CODE             OUT  NUMBER) IS

/* Declare constants */
PROC_NAME             CONSTANT  VARCHAR2(31) := '.UPDATE_SEC_LEVEL';


/* Declare variables */
NO_MESSAGE            EXCEPTION;
APPL_ERROR            EXCEPTION;
NO_DATA               EXCEPTION;
V_SEC_CHECK			  NUMBER;
V_INACTIVE_SEC		  NUMBER;
V_CHK_AGGR			  NUMBER;
WARNING_CHECK		  NUMBER				 := 0;
CHECK_ERR			  NUMBER				 := 0;
WARNING_MSG			  VARCHAR2(200);
V_PREV_UINFIN		  VARCHAR2(14);

/* Declare Cursor */
CURSOR check_exist_sec_data_cursor
	(p_school_code VARCHAR2, p_level_code VARCHAR2, p_uin_fin_no VARCHAR2) IS
SELECT	COUNT(1)
  FROM	CP_OUTBOUND_EASA_SEC_TEMP
 WHERE	school_code = p_school_code
   AND	level_xcode = p_level_code
   AND	uin_fin_no = p_uin_fin_no;

CURSOR	RETRIEVE_SEC_INACTIVE_CURSOR
		(p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT	sp.uin_fin_no
  FROM	CP_STUD_PROFILE SP
 WHERE	STUDENT_STATUS_ICODE = 'I'
   AND	ACADEMIC_YEAR = p_academic_year
   AND	LEVEL_XCODE = p_level_code
   AND	SCHOOL_CODE = p_school_code;

CURSOR	RETRIEVE_AGG_CURSOR
		(p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT	COUNT(1)
  FROM	CP_STUD_HIST_RES_AGGREGATES CRA, --<MOD-012>--
        CP_STUD_HIST_PROMOTION CSP
 WHERE	CRA.ACADEMIC_YEAR = p_academic_year
   AND  CRA.RESULT_TYPE_ICODE = OVERALL
   AND  CSP.SCHOOL_CODE = p_school_code
   AND  CSP.LEVEL_XCODE = p_level_code
   AND  CSP.ACADEMIC_YEAR = CRA.ACADEMIC_YEAR
   AND  CSP.STUDENT_ID = CRA.STUDENT_ID
   AND  CSP.STUDENT_STATUS_ICODE = 'A';

CURSOR  RETRIEVE_SEC_CURRENT_CURSOR
        (p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT  sp.academic_year                        academic_year,
	sp.student_id				student_id,
	sp.uin_fin_no                           uin_fin_no,
	sp.class_xcode,
	ag.eass_overall_percentages_no	        eass_overall_percentages_no,
	ag.pass_ind                             pass_ind,
	rm.overall_conduct_code                 conduct_code --<MOD-013>--
  FROM  CP_STUD_HIST_RES_AGGREGATES ag,
        CP_STUD_HIST_RES_REMARKS rm,
        CP_STUD_PROFILE sp
 WHERE  rm.student_id(+) = sp.student_id
   AND  RM.ACADEMIC_YEAR(+) = P_ACADEMIC_YEAR
   AND  RM.RESULT_TYPE_ICODE(+) = OVERALL --SECOND_ICODE --<MOD-014>--
   AND  AG.STUDENT_ID(+) = SP.STUDENT_ID
   AND  AG.RESULT_TYPE_ICODE(+) = OVERALL --<MOD-012>--
   AND  ag.academic_year(+) = p_academic_year
   AND  sp.student_status_icode = ACTIVE
   --AND  (sp.leave_of_absence_ind = 'N' OR sp.leave_of_absence_ind IS NULL) ---- Not necessery as active students are picked up
   AND  sp.academic_year = TO_CHAR(SYSDATE, 'YYYY')
   AND  sp.level_xcode = p_level_code
   AND  sp.school_code = p_school_code
   ORDER BY sp.uin_fin_no;

CURSOR RETRIEVE_PREV_NRIC_CURSOR
		(p_student_id VARCHAR2) IS
SELECT CAPN.PREV_UIN_FIN_NO
  FROM CP_ARCH_PREV_NRIC CAPN
 WHERE CAPN.PERSON_ID = p_student_id;

BEGIN

	/* REMOVE INACTIVE STUDENTS FROM THE OUTBOUND TABLES */
	FOR INACTIVE_RECORD IN RETRIEVE_SEC_INACTIVE_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR)
	LOOP
		/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
		OPEN check_exist_sec_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, INACTIVE_RECORD.uin_fin_no);
		FETCH check_exist_sec_data_cursor INTO V_INACTIVE_SEC;
		IF NOT check_exist_sec_data_cursor%ISOPEN THEN
			CLOSE check_exist_sec_data_cursor;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF check_exist_sec_data_cursor%NOTFOUND THEN
			CLOSE check_exist_sec_data_cursor;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE check_exist_sec_data_cursor;

		/* DELETE STUDENT FROM OUTBOUND TABLE IF STUDENT IS INACTIVE */
		IF V_INACTIVE_SEC > 0
			THEN
				DELETE FROM CP_OUTBOUND_EASA_SEC_TEMP
				 WHERE SCHOOL_CODE = V_SCHOOL_CODE
				   AND LEVEL_XCODE = V_LEVEL_CODE
				   AND UIN_FIN_NO  = INACTIVE_RECORD.uin_fin_no
				   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

				IF SQL%NOTFOUND THEN
					V_RET_CODE := FAIL;
					RAISE APPL_ERROR;
				END IF;

				/* Commit changes */
				COMMIT;
			END IF;

	END LOOP;

	WARNING_CHECK := 0;
	CHECK_ERR := 0;
	FOR tmp_record IN RETRIEVE_SEC_CURRENT_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR)
	LOOP
		/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
		OPEN check_exist_sec_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, tmp_record.uin_fin_no);
		FETCH check_exist_sec_data_cursor INTO V_SEC_CHECK;
		IF NOT check_exist_sec_data_cursor%ISOPEN THEN
			CLOSE check_exist_sec_data_cursor;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF check_exist_sec_data_cursor%NOTFOUND THEN
			CLOSE check_exist_sec_data_cursor;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE check_exist_sec_data_cursor;

		/* IF STUDENT CANNOT BE FOUND IN TEMP TABLE, CHECK IF USER CHANGED UINFIN. */
		IF V_SEC_CHECK = 0 OR V_SEC_CHECK IS NULL
		THEN

			OPEN RETRIEVE_PREV_NRIC_CURSOR(tmp_record.student_id);
			FETCH RETRIEVE_PREV_NRIC_CURSOR INTO V_PREV_UINFIN;
			IF NOT RETRIEVE_PREV_NRIC_CURSOR%ISOPEN THEN

				CLOSE RETRIEVE_PREV_NRIC_CURSOR;
				V_RET_CODE := SQLCODE;
				RAISE APPL_ERROR;
			ELSIF RETRIEVE_PREV_NRIC_CURSOR%NOTFOUND THEN

				--CLOSE RETRIEVE_PREV_NRIC_CURSOR;
				--V_RET_CODE := FAIL;
				--RAISE APPL_ERROR;
				V_PREV_UINFIN := NULL;
			END IF;
			CLOSE RETRIEVE_PREV_NRIC_CURSOR;

			/* IF USER CHANGED NRIC, CHECK IF USER EXIST IN TEMP TABLE WITH PREV NRIC. */
			IF V_PREV_UINFIN IS NOT NULL
			THEN

				/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
				OPEN check_exist_sec_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, V_PREV_UINFIN);
				FETCH check_exist_sec_data_cursor INTO V_SEC_CHECK;
				IF NOT check_exist_sec_data_cursor%ISOPEN THEN
					CLOSE check_exist_sec_data_cursor;
					V_RET_CODE := SQLCODE;
					RAISE APPL_ERROR;
				ELSIF check_exist_sec_data_cursor%NOTFOUND THEN
					CLOSE check_exist_sec_data_cursor;
					V_RET_CODE := FAIL;
					RAISE APPL_ERROR;
				END IF;
				CLOSE check_exist_sec_data_cursor;

				IF V_SEC_CHECK > 0 THEN
					BEGIN
						DELETE FROM CP_OUTBOUND_EASA_SEC_TEMP
						 WHERE SCHOOL_CODE = V_SCHOOL_CODE
						   AND LEVEL_XCODE = V_LEVEL_CODE
						   AND UIN_FIN_NO  = V_PREV_UINFIN
						   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

						EXCEPTION
						WHEN OTHERS THEN
							--dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
							dbms_output.put_line(SQLCODE);
							dbms_output.put_line(SQLERRM);
					END;
					--IF SQL%NOTFOUND THEN
					--	V_RET_CODE := FAIL;
					--	RAISE APPL_ERROR;
					--END IF;

					/* Commit changes */
					BEGIN
						COMMIT;
						EXCEPTION
						WHEN OTHERS THEN
							--dbms_output.put_line('COMMIT_ERROR');
							dbms_output.put_line(SQLCODE);
							dbms_output.put_line(SQLERRM);
					END;
					/* RESET V_SEC_CHECK, SO THAT RECORD WILL BE INSERTED. */
					V_SEC_CHECK := 0;
				END IF;
			END IF;
		END IF;

		/* Check if the aggreate is calculated for the level(at least) or not if not warn user.
		Not necessery to verify level stream combination*/
		OPEN RETRIEVE_AGG_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR);
		FETCH RETRIEVE_AGG_CURSOR INTO V_CHK_AGGR;
		IF NOT RETRIEVE_AGG_CURSOR%ISOPEN THEN
		--dbms_output.put_line('fetch');
			CLOSE RETRIEVE_AGG_CURSOR;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF RETRIEVE_AGG_CURSOR%NOTFOUND THEN
		--dbms_output.put_line('fetch else if');
			CLOSE RETRIEVE_AGG_CURSOR;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE RETRIEVE_AGG_CURSOR;

		IF (V_CHK_AGGR IS NULL OR V_CHK_AGGR = 0) THEN
				--dbms_output.put_line('1st WARN %' );
		    BEGIN
			WARNING_MSG := AGGR_WARNING || V_SCHOOL_CODE || ',' || V_LEVEL_CODE || V_ACADEMIC_YEAR;
			CHECK_ERR := 1;

			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;
		END IF;

		/* IF EASA_OVERALL_PERCENTAGES_NO IS NULL, GENERATE WARNING MESSAGE */
		IF tmp_record.eass_overall_percentages_no IS NULL THEN				-- edited by Wilfred
		   BEGIN
			WARNING_MSG := STUD_WARNING || tmp_record.uin_fin_no || ',' || tmp_record.class_xcode || EASA_OVERALL_AV_WARNING;
			CHECK_ERR := 1;
			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;

		END IF;
		/* IF PASS_IND IS NULL, GENERATE WARNING MESSAGE */
		/*IF tmp_record.pass_ind IS NULL AND CHECK_ERR != 1 THEN
			WARNING_MSG := STUD_WARNING || tmp_record.uin_fin_no || ',' || tmp_record.class_xcode || PASS_IND_WARNING;
			CHECK_ERR := 1;
		END IF;*/
		/* WARNING MESSAGE TO BE GENERATED */
		IF CHECK_ERR = 1 THEN
		BEGIN
			INSERT INTO CP_ARCH_JOB_ERRORS(
								JOB_REFID,
								JOB_ERROR_XCODE,
								REMARKS_DESC,
								RECORD_VERSION_NO,
								CREATED_DATE,
								CREATED_BY_ID,
								LAST_UPDATED_DATE,
								UPDATED_BY_ID
								)
			VALUES
								(I_JOB_REF_ID,
								ERROR_XCODE,
								WARNING_MSG,
								1,
								SYSDATE,
								V_USER_ID,
								SYSDATE,
								V_USER_ID
								);
			EXCEPTION
			   WHEN DUP_VAL_ON_INDEX THEN
					--dbms_output.put_line('DUPLICAE-M');
			        NULL;
			   WHEN OTHERS THEN
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		    END;
			/* Commit changes */
			BEGIN
			COMMIT;
			EXCEPTION
			   WHEN OTHERS THEN
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		    END;
			/* NOTIFIED THE CALLING PROCEDURE THAT THERE IS WARNING MESSAGE GENERATED */
			WARNING_CHECK := 1;
			CHECK_ERR := 0;

			IF V_SEC_CHECK > 0
			THEN
			BEGIN
				DELETE FROM CP_OUTBOUND_EASA_SEC_TEMP
				 WHERE SCHOOL_CODE = V_SCHOOL_CODE
				   AND LEVEL_XCODE = V_LEVEL_CODE
				   AND UIN_FIN_NO  = tmp_record.uin_fin_no
				   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

			EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
					--V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;

			END IF;

		ELSE

			/* IF EXIST IN CP_OUTBOUND_EASA_SEC_TEMP TABLE, DO A UPDATE */
			IF V_SEC_CHECK > 0
			THEN
			BEGIN
				UPDATE CP_OUTBOUND_EASA_SEC_TEMP SET EASA_OVERALL_PERCENTAGES_NO = tmp_record.eass_overall_percentages_no,
						S2_OVERALL_CONDUCT_CODE = tmp_record.conduct_code,
            PASS_IND = tmp_record.pass_ind,
						LAST_UPDATED_DATE = SYSDATE,
						UPDATED_BY_ID = V_USER_ID
				WHERE	SCHOOL_CODE = V_SCHOOL_CODE
					AND LEVEL_XCODE = V_LEVEL_CODE
					AND UIN_FIN_NO = tmp_record.uin_fin_no
					AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;
			EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
					--V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			/* IF NOT EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE, DO AN INSERT */
			ELSE
			BEGIN
				INSERT INTO CP_OUTBOUND_EASA_SEC_TEMP(
								SCHOOL_CODE,
								LEVEL_XCODE,
								ACADEMIC_YEAR,
								UIN_FIN_NO,
								EASA_OVERALL_PERCENTAGES_NO,
								PASS_IND,
								S2_OVERALL_CONDUCT_CODE,
								CREATED_DATE,
								CREATED_BY_ID,
								LAST_UPDATED_DATE,
								UPDATED_BY_ID)
				VALUES
								(V_SCHOOL_CODE,
								V_LEVEL_CODE,
								V_ACADEMIC_YEAR,
								tmp_record.uin_fin_no,
								tmp_record.eass_overall_percentages_no,
								tmp_record.pass_ind,
								tmp_record.conduct_code,
								SYSDATE,
								V_USER_ID,
								SYSDATE,
								V_USER_ID);
			EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
					--V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			END IF;
		END IF;
	END LOOP;


IF WARNING_CHECK = 1 THEN
	O_RETURN_CODE := WARNING;
ELSE
	/* Return success code */
	O_RETURN_CODE := SUCCESS;
END IF;

EXCEPTION
  WHEN NO_MESSAGE THEN
    /* No Summary */
    O_RETURN_CODE       := SUCCESS;

  WHEN NO_DATA THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN APPL_ERROR THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN OTHERS THEN
    /*  SQL error */
	DBMS_OUTPUT.PUT_LINE('SQLEXCEPION');
    O_RETURN_CODE       := SQLCODE;

END UPDATE_SEC_LEVEL;

/*******************************************************************************
  * Procedure Name: UPDATE_JCCI_LEVEL()
  * Description:    Retrieve student that are eligible for EASA.
 ******************************************************************************/

PROCEDURE UPDATE_JCCI_LEVEL(I_JOB_REF_ID              IN   NUMBER,
						    O_RETURN_CODE             OUT  NUMBER) IS

/* Declare constants */
PROC_NAME             CONSTANT  VARCHAR2(31) := '.UPDATE_JCCI_LEVEL';

/* Declare variables */
NO_MESSAGE            EXCEPTION;
APPL_ERROR            EXCEPTION;
NO_DATA               EXCEPTION;
V_JC_CHECK			  NUMBER;
V_INACTIVE_JC		  NUMBER;
V_CHK_AGGR			  NUMBER;
WARNING_CHECK		  NUMBER				 := 0;
CHECK_ERR			  NUMBER				 := 0;
WARNING_MSG			  VARCHAR2(200);
V_PREV_UINFIN		  VARCHAR2(14);

/* Declare Cursor */
CURSOR check_exist_jcci_data_cursor
	(p_school_code VARCHAR2, p_level_code VARCHAR2, p_uin_fin_no VARCHAR2) IS
SELECT	COUNT(1)
  FROM	CP_OUTBOUND_EASA_JC_TEMP
 WHERE	school_code = p_school_code
   AND	level_xcode = p_level_code
   AND	uin_fin_no = p_uin_fin_no;

CURSOR	RETRIEVE_JC_INACTIVE_CURSOR
		(p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT	sp.uin_fin_no
  FROM	CP_STUD_PROFILE SP
 WHERE	STUDENT_STATUS_ICODE = 'I'
   AND	ACADEMIC_YEAR = p_academic_year
   AND	LEVEL_XCODE = p_level_code
   AND	SCHOOL_CODE = p_school_code;

CURSOR	RETRIEVE_AGG_CURSOR
		(p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT	COUNT(1)
  FROM	CP_STUD_HIST_RES_AGGREGATES CRA, CP_STUD_HIST_PROMOTION CSP --<MOD-015>--
 WHERE	--SCHOOL_CODE = p_school_code
   --AND LEVEL_XCODE = p_level_code   AND
        CSP.SCHOOL_CODE = p_school_code
   AND  CSP.ACADEMIC_YEAR = p_academic_year
   AND  CSP.STUDENT_STATUS_ICODE = 'A'
   AND  CRA.STUDENT_ID = CSP.STUDENT_ID
   AND  CRA.ACADEMIC_YEAR = CSP.ACADEMIC_YEAR
   AND  CRA.RESULT_TYPE_ICODE = OVERALL ;  --<MOD-016>--


CURSOR  RETRIEVE_JCCI_CURRENT_CURSOR
        (p_school_code VARCHAR2, p_level_code VARCHAR2, p_academic_year VARCHAR2) IS
SELECT sp.academic_year												academic_year,
	sp.student_id													student_id,
	sp.uin_fin_no													uin_fin_no,
	sp.class_xcode,
	ag.ranking_points_no											ranking_pts,
	TO_CHAR(NVL(SUM(DECODE(mk.grade_name, 'A', 1, 0)), 0))							count_grade_a,--<MOD-017>--
    TO_CHAR(NVL(SUM(DECODE(mk.grade_name, 'B', 1, 0)), 0))							count_grade_b,--<MOD-018>--
	rm.overall_conduct_code											conduct_code, --<MOD-019>--
	ag.acadaward_eligibility_ind										acad_award_eligibility_ind
  FROM  --<START MOD-020>--
	CP_STUD_HIST_RES_AGGREGATES ag,
        CP_STUD_HIST_RES_REMARKS rm,
        CP_STUD_HIST_RES_MARKS mk,
	--<END MOD-020>--
        CP_STUD_PROFILE sp
 WHERE  rm.student_id(+) = sp.student_id
   AND  rm.academic_year(+) = p_academic_year
   AND  AG.STUDENT_ID(+) = SP.STUDENT_ID
   AND  AG.RESULT_TYPE_ICODE(+) = OVERALL
   AND  AG.ACADEMIC_YEAR(+) = P_ACADEMIC_YEAR
   AND  MK.STUDENT_ID(+) = SP.STUDENT_ID
   AND  MK.ACADEMIC_YEAR(+) = SP.ACADEMIC_YEAR
   AND  mk.subject_active_ind = YES
   --<START ADD-003>--
   AND  MK.RESULT_TYPE_ICODE(+) = OVERALL
   AND  rm.result_type_icode(+) = OVERALL
   --<END ADD-003>--
   AND (mk.subject_code, mk.subject_level_xcode, mk.subject_stream_xcode) IN
	(SELECT od.subject_code, od.level_xcode, od.stream_xcode
			FROM CP_SUBJ_LEVEL_STREAM od
			WHERE od.subject_level_icode = DECODE(sp.new_jcci_cur_ind,'Y','08','01') -- To cater for the new JCCI curriculum
			AND od.level_xcode           = mk.subject_level_xcode 		   -- added newly to cater for outof stream subjects
			AND od.stream_xcode          = mk.SUBJECT_STREAM_XCODE 		   -- added newly to cater for outof stream subjects
			AND od.academic_year         = mk.academic_year )
	AND  (mk.subject_code, mk.subject_level_xcode, mk.subject_stream_xcode) IN
	 (SELECT od1.subject_code, od1.level_xcode, od1.stream_xcode
			FROM CP_CUR_SCHOOL_HIST_SUBJ od1 --<MOD-021>--
			WHERE  od1.subject_school_code = p_school_code --<ADD-004>--
                        AND od1.academic_year          = p_academic_year
			AND od1.level_xcode            = mk.subject_level_xcode             -- added newly to cater for outof stream subjects
			AND od1.stream_xcode           = mk.SUBJECT_STREAM_XCODE 	    -- added newly to cater for outof stream subjects
			AND OD1.EXAMINABLE_IND         = YES )
   AND  mk.subject_active_ind = YES
   AND  mk.academic_year = p_academic_year
   AND  sp.student_status_icode = ACTIVE
  -- AND  (sp.leave_of_absence_ind = 'N' OR sp.leave_of_absence_ind IS NULL) -- Not necessery as active students are picked up
   AND  sp.academic_year = p_academic_year --TO_CHAR(SYSDATE, 'YYYY')
   AND  sp.level_xcode = p_level_code
   AND  sp.school_code = p_school_code
 GROUP BY sp.academic_year, sp.student_id, sp.uin_fin_no, sp.class_xcode, ag.ranking_points_no, rm.overall_conduct_code, ag.acadaward_eligibility_ind
 ORDER BY sp.uin_fin_no;

CURSOR RETRIEVE_PREV_NRIC_CURSOR
		(p_student_id VARCHAR2) IS
SELECT CAPN.PREV_UIN_FIN_NO
  FROM CP_ARCH_PREV_NRIC CAPN
 WHERE CAPN.PERSON_ID = p_student_id;

BEGIN

	/* REMOVE INACTIVE STUDENTS FROM THE OUTBOUND TABLES */
	FOR INACTIVE_RECORD IN RETRIEVE_JC_INACTIVE_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR)
	LOOP
		/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
		OPEN check_exist_jcci_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, INACTIVE_RECORD.uin_fin_no);
		FETCH check_exist_jcci_data_cursor INTO V_INACTIVE_JC;
		IF NOT check_exist_jcci_data_cursor%ISOPEN THEN
			CLOSE check_exist_jcci_data_cursor;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF check_exist_jcci_data_cursor%NOTFOUND THEN
			CLOSE check_exist_jcci_data_cursor;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE check_exist_jcci_data_cursor;

		/* DELETE STUDENT FROM OUTBOUND TABLE IF STUDENT IS INACTIVE */
		IF V_INACTIVE_JC > 0
			THEN
				DELETE FROM CP_OUTBOUND_EASA_JC_TEMP
				 WHERE SCHOOL_CODE = V_SCHOOL_CODE
				   AND LEVEL_XCODE = V_LEVEL_CODE
				   AND UIN_FIN_NO  = INACTIVE_RECORD.uin_fin_no
				   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

				IF SQL%NOTFOUND THEN
					V_RET_CODE := FAIL;
					RAISE APPL_ERROR;
				END IF;

				/* Commit changes */
				COMMIT;
			END IF;

	END LOOP;

	WARNING_CHECK := 0;
	CHECK_ERR := 0;

	FOR tmp_record IN RETRIEVE_JCCI_CURRENT_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR)
	LOOP
		/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
		OPEN check_exist_jcci_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, tmp_record.uin_fin_no);
		FETCH check_exist_jcci_data_cursor INTO V_JC_CHECK;
		IF NOT check_exist_jcci_data_cursor%ISOPEN THEN
			CLOSE check_exist_jcci_data_cursor;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF check_exist_jcci_data_cursor%NOTFOUND THEN
			CLOSE check_exist_jcci_data_cursor;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE check_exist_jcci_data_cursor;

		/* IF STUDENT CANNOT BE FOUND IN TEMP TABLE, CHECK IF USER CHANGED UINFIN. */
		IF V_JC_CHECK = 0 OR V_JC_CHECK IS NULL
		THEN

			OPEN RETRIEVE_PREV_NRIC_CURSOR(tmp_record.student_id);
			FETCH RETRIEVE_PREV_NRIC_CURSOR INTO V_PREV_UINFIN;
			IF NOT RETRIEVE_PREV_NRIC_CURSOR%ISOPEN THEN

				CLOSE RETRIEVE_PREV_NRIC_CURSOR;
				V_RET_CODE := SQLCODE;
				RAISE APPL_ERROR;
			ELSIF RETRIEVE_PREV_NRIC_CURSOR%NOTFOUND THEN

				--CLOSE RETRIEVE_PREV_NRIC_CURSOR;
				--V_RET_CODE := FAIL;
				--RAISE APPL_ERROR;
				V_PREV_UINFIN := NULL;
			END IF;
			CLOSE RETRIEVE_PREV_NRIC_CURSOR;

			/* IF USER CHANGED NRIC, CHECK IF USER EXIST IN TEMP TABLE WITH PREV NRIC. */
			IF V_PREV_UINFIN IS NOT NULL
			THEN

				/* CHECK IF RECORD ALREADY EXIST IN CP_OUTBOUND_EASA_PRI_TEMP TABLE */
				OPEN check_exist_jcci_data_cursor(V_SCHOOL_CODE, V_LEVEL_CODE, V_PREV_UINFIN);
				FETCH check_exist_jcci_data_cursor INTO V_JC_CHECK;
				IF NOT check_exist_jcci_data_cursor%ISOPEN THEN
					CLOSE check_exist_jcci_data_cursor;
					V_RET_CODE := SQLCODE;
					RAISE APPL_ERROR;
				ELSIF check_exist_jcci_data_cursor%NOTFOUND THEN
					CLOSE check_exist_jcci_data_cursor;
					V_RET_CODE := FAIL;
					RAISE APPL_ERROR;
				END IF;
				CLOSE check_exist_jcci_data_cursor;

				IF V_JC_CHECK > 0 THEN
					BEGIN
						DELETE FROM CP_OUTBOUND_EASA_JC_TEMP
						 WHERE SCHOOL_CODE = V_SCHOOL_CODE
						   AND LEVEL_XCODE = V_LEVEL_CODE
						   AND UIN_FIN_NO  = V_PREV_UINFIN
						   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

						EXCEPTION
						WHEN OTHERS THEN
							--dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
							dbms_output.put_line(SQLCODE);
							dbms_output.put_line(SQLERRM);
					END;
					--IF SQL%NOTFOUND THEN
					--	V_RET_CODE := FAIL;
					--	RAISE APPL_ERROR;
					--END IF;

					/* Commit changes */
					BEGIN
						COMMIT;
						EXCEPTION
						WHEN OTHERS THEN
							--dbms_output.put_line('COMMIT_ERROR');
							dbms_output.put_line(SQLCODE);
							dbms_output.put_line(SQLERRM);
					END;
					/* RESET V_JC_CHECK, SO THAT RECORD WILL BE INSERTED. */
					V_JC_CHECK := 0;
				END IF;
			END IF;
		END IF;

		/* Check if the aggreate is calculated for the level(at least) or not if not warn user.
		Not necessery to verify level stream combination*/
		OPEN RETRIEVE_AGG_CURSOR(V_SCHOOL_CODE, V_LEVEL_CODE, V_ACADEMIC_YEAR);
		FETCH RETRIEVE_AGG_CURSOR INTO V_CHK_AGGR;
		IF NOT RETRIEVE_AGG_CURSOR%ISOPEN THEN
		--dbms_output.put_line('fetch');
			CLOSE RETRIEVE_AGG_CURSOR;
			V_RET_CODE := SQLCODE;
			RAISE APPL_ERROR;
		ELSIF RETRIEVE_AGG_CURSOR%NOTFOUND THEN
		--dbms_output.put_line('fetch else if');
			CLOSE RETRIEVE_AGG_CURSOR;
			V_RET_CODE := FAIL;
			RAISE APPL_ERROR;
		END IF;
		CLOSE RETRIEVE_AGG_CURSOR;

		IF (V_CHK_AGGR IS NULL OR V_CHK_AGGR = 0) THEN
				--dbms_output.put_line('1st WARN %' );
		    BEGIN
			WARNING_MSG := AGGR_WARNING || V_SCHOOL_CODE || ',' || V_LEVEL_CODE || V_ACADEMIC_YEAR;
			CHECK_ERR := 1;

			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;
		END IF;

		/* IF RANKING_PTS IS NULL, GENERATE WARNING MESSAGE */
		IF tmp_record.ranking_pts IS NULL THEN				-- edited by Wilfred
		   BEGIN
			WARNING_MSG := STUD_WARNING || tmp_record.uin_fin_no || ',' || tmp_record.class_xcode || RANKING_PTS_WARNING;
			CHECK_ERR := 1;
			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;

		END IF;
		/* IF ACADAWARD_ELIGIBILITY_IND IS NULL, GENERATE WARNING MESSAGE */
		IF tmp_record.acad_award_eligibility_ind IS NULL AND CHECK_ERR != 1 THEN
		   BEGIN
			WARNING_MSG := STUD_WARNING || tmp_record.uin_fin_no || ',' || tmp_record.class_xcode || ACADAWARD_WARNING;
			CHECK_ERR := 1;
			EXCEPTION
			    WHEN OTHERS THEN
			  --dbms_output.put_line('1st WARN EXCEPZTION');
		        dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
		    END;

		END IF;
		/* WARNING MESSAGE TO BE GENERATED */
		IF CHECK_ERR = 1 THEN
		   BEGIN
			INSERT INTO CP_ARCH_JOB_ERRORS(
								JOB_REFID,
								JOB_ERROR_XCODE,
								REMARKS_DESC,
								RECORD_VERSION_NO,
								CREATED_DATE,
								CREATED_BY_ID,
								LAST_UPDATED_DATE,
								UPDATED_BY_ID
								)
			VALUES
								(I_JOB_REF_ID,
								ERROR_XCODE,
								WARNING_MSG,
								1,
								SYSDATE,
								V_USER_ID,
								SYSDATE,
								V_USER_ID
								);
			EXCEPTION
				WHEN DUP_VAL_ON_INDEX THEN
					 --dbms_output.put_line('DUPLICAE-M');
					 NULL;
				WHEN OTHERS THEN
				dbms_output.put_line(SQLCODE);
				dbms_output.put_line(SQLERRM);
			END;
			--IF SQL%NOTFOUND THEN
				--V_RET_CODE := FAIL;
				--RAISE APPL_ERROR;
			--			END IF;
			/* Commit changes */
			BEGIN
			COMMIT;
			EXCEPTION
					 WHEN OTHERS THEN
					 dbms_output.put_line(SQLCODE);
					 dbms_output.put_line(SQLERRM);
			END;
			/* NOTIFIED THE CALLING PROCEDURE THAT THERE IS WARNING MESSAGE GENERATED */
			WARNING_CHECK := 1;
			CHECK_ERR := 0;
			--out_status :='Error to be stored in error table';

			IF V_JC_CHECK > 0
			THEN
			BEGIN
				DELETE FROM CP_OUTBOUND_EASA_JC_TEMP
				 WHERE SCHOOL_CODE = V_SCHOOL_CODE
				   AND LEVEL_XCODE = V_LEVEL_CODE
				   AND UIN_FIN_NO  = tmp_record.uin_fin_no
				   AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

			    EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
					--V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			END IF;

		ELSE

			/* IF EXIST IN CP_OUTBOUND_EASA_JC_TEMP TABLE, DO A UPDATE */
			IF V_JC_CHECK > 0
			THEN
			BEGIN
				UPDATE CP_OUTBOUND_EASA_JC_TEMP SET RANKING_POINTS_NO = tmp_record.ranking_pts,
						GRADE_A_NO = tmp_record.count_grade_a,
						GRADE_B_NO = tmp_record.count_grade_b,
						OV_OVERALL_CONDUCT_CODE = tmp_record.conduct_code,
						ACADAWARD_ELIGIBILITY_IND = tmp_record.acad_award_eligibility_ind,
						LAST_UPDATED_DATE = SYSDATE,
						UPDATED_BY_ID = V_USER_ID
				WHERE	SCHOOL_CODE = V_SCHOOL_CODE
					AND LEVEL_XCODE = V_LEVEL_CODE
					AND UIN_FIN_NO = tmp_record.uin_fin_no
					AND ACADEMIC_YEAR = V_ACADEMIC_YEAR;

			 EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
					--V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;			/* IF EXIST IN CP_OUTBOUND_EASA_JC_TEMP TABLE, DO AN INSERT */
			ELSE
			BEGIN
				INSERT INTO CP_OUTBOUND_EASA_JC_TEMP(
								SCHOOL_CODE,
								LEVEL_XCODE,
								ACADEMIC_YEAR,
								UIN_FIN_NO,
								RANKING_POINTS_NO,
								GRADE_A_NO,
								GRADE_B_NO,
								OV_OVERALL_CONDUCT_CODE,
								ACADAWARD_ELIGIBILITY_IND,
								CREATED_DATE,
								CREATED_BY_ID,
								LAST_UPDATED_DATE,
								UPDATED_BY_ID)
				VALUES
								(V_SCHOOL_CODE,
								V_LEVEL_CODE,
								V_ACADEMIC_YEAR,
								tmp_record.uin_fin_no,
								tmp_record.ranking_pts,
								tmp_record.count_grade_a,
								tmp_record.count_grade_b,
								tmp_record.conduct_code,
								tmp_record.acad_award_eligibility_ind,
								SYSDATE,
								V_USER_ID,
								SYSDATE,
								V_USER_ID);
			EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('deletion cp_outbound_EASA_PRI_TEMP');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
				--IF SQL%NOTFOUND THEN
					--V_RET_CODE := FAIL;
				--	RAISE APPL_ERROR;
				--END IF;

				/* Commit changes */
				BEGIN
				COMMIT;
				EXCEPTION
			    WHEN OTHERS THEN
				    --dbms_output.put_line('COMMIT_ERROR');
			        dbms_output.put_line(SQLCODE);
					dbms_output.put_line(SQLERRM);
		        END;
			END IF;
		END IF;
	END LOOP;

IF WARNING_CHECK = 1 THEN
	O_RETURN_CODE := WARNING;
ELSE
	/* Return success code */
	O_RETURN_CODE := SUCCESS;
END IF;

EXCEPTION
  WHEN NO_MESSAGE THEN
    /* No Summary */
    O_RETURN_CODE       := SUCCESS;

  WHEN NO_DATA THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN APPL_ERROR THEN
    /* Application error */
    O_RETURN_CODE       := V_RET_CODE;

  WHEN OTHERS THEN
    /*  SQL error */
    O_RETURN_CODE       := SQLCODE;

END UPDATE_JCCI_LEVEL;

END Cp_Res_Pkg_Easa;
